name: Claude Code Review

# Make this workflow callable by other repositories
on:
  workflow_call:
    inputs:
      framework:
        type: string
        required: false
        default: 'generic'
        description: 'Framework type: next, nest, react, generic, etc'
      trigger:
        type: string
        required: false
        default: 'auto'
        description: "Trigger mode: 'label' or 'auto' (auto runs for all PRs)"
      pr_number:
        type: number
        required: true
        description: 'Pull request number to review'
    secrets:
      ANTHROPIC_API_KEY:
        required: true
        description: 'Anthropic API key for Claude'

jobs:
  # delete-old-claude-comments:
  #   name: cleanup-old-claude-comments
  #   runs-on: ubuntu-latest
  #   permissions:
  #     pull-requests: write
  #
  #   steps:
  #     - name: Determine trigger
  #       id: determine-trigger
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const mode = '${{ inputs.trigger }}';
  #           const { data: pr } = await github.rest.pulls.get({
  #             owner: context.repo.owner,
  #             repo: context.repo.repo,
  #             pull_number: context.payload.pull_request.number
  #           });
  #           const hasClaudeLabel = pr.labels.some(label => label.name === 'claude');
  #           let shouldRun = false;
  #           if (mode === 'label') {
  #             shouldRun = hasClaudeLabel;
  #           } else {
  #             shouldRun = true;
  #           }
  #           core.setOutput('has-claude-label', hasClaudeLabel.toString());
  #           core.setOutput('should-run', shouldRun.toString());
  #
  #     - name: Clean up old comments
  #       if: steps.determine-trigger.outputs.should-run == 'true'
  #       uses: actions/github-script@v7
  #       with:
  #         script: |
  #           const params = { pull_number: context.payload.pull_request.number, owner: context.repo.owner, repo: context.repo.repo }
  #           console.log(`Checking PR ${params.pull_number} for claude[bot] comments...`);
  #
  #           const issueComments = await github.rest.issues.listComments({ issue_number: params.pull_number, owner: params.owner, repo: params.repo });
  #           const reviewComments = await github.rest.pulls.listReviewComments(params);
  #
  #           let deletedCount = 0;
  #
  #           for (const comment of issueComments.data) {
  #             if (comment.user.login === 'claude[bot]') {
  #               await github.rest.issues.deleteComment({ issue_number: params.pull_number, owner: params.owner, repo: params.repo, comment_id: comment.id });
  #               deletedCount++;
  #             }
  #           }
  #
  #           for (const comment of reviewComments.data) {
  #             if (comment.user.login === 'claude[bot]') {
  #               await github.rest.pulls.deleteReviewComment({ pull_number: params.pull_number, owner: params.owner, repo: params.repo, comment_id: comment.id });
  #               deletedCount++;
  #             }
  #           }
  #
  review:
    name: claude-review-pull-request
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      id-token: write
      issues: write
      actions: read
    steps:
      - uses: actions/checkout@v5
        with:
          fetch-depth: 1

      - name: Determine trigger
        id: determine-trigger
        uses: actions/github-script@v7
        with:
          script: |
            const mode = '${{ inputs.trigger }}';
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            const hasClaudeLabel = pr.labels.some(label => label.name === 'claude');
            let shouldRun = false;
            if (mode === 'label') {
              shouldRun = hasClaudeLabel;
            } else {
              shouldRun = true;
            }
            core.setOutput('has-claude-label', hasClaudeLabel.toString());
            core.setOutput('should-run', shouldRun.toString());

      - name: Read cursor rules
        if: steps.determine-trigger.outputs.should-run == 'true'
        id: cursor-rules
        run: |
          if [ -d ".cursor/rules" ] && [ "$(ls .cursor/rules/*.mdc 2>/dev/null | wc -l)" -gt 0 ]; then
            delimiter="$(openssl rand -hex 8)"
            echo "content<<${delimiter}" >> $GITHUB_OUTPUT
            cat .cursor/rules/*.mdc >> $GITHUB_OUTPUT
            echo "" >> $GITHUB_OUTPUT
            echo "${delimiter}" >> $GITHUB_OUTPUT
          else
            echo "content=No cursor rules found" >> $GITHUB_OUTPUT
          fi

      # Download framework-specific rules from this repository
      - name: Download framework rules
        if: steps.determine-trigger.outputs.should-run == 'true'
        id: framework-rules
        run: |
          FRAMEWORK="${{ inputs.framework }}"
          RULES_URL="https://raw.githubusercontent.com/${{ github.repository }}/main/rules/${FRAMEWORK}.md"
          
          echo "Attempting to download rules for framework: ${FRAMEWORK}"
          echo "URL: ${RULES_URL}"
          
          delimiter="$(openssl rand -hex 8)"
          echo "content<<${delimiter}" >> $GITHUB_OUTPUT
          
          # Try to download framework-specific rules
          if curl -f -s "${RULES_URL}" -o /tmp/framework-rules.md 2>/dev/null; then
            echo "Successfully downloaded ${FRAMEWORK} rules"
            cat /tmp/framework-rules.md >> $GITHUB_OUTPUT
          else
            echo "No framework-specific rules found for: ${FRAMEWORK}" >> $GITHUB_OUTPUT
            echo "Using default review guidelines." >> $GITHUB_OUTPUT
          fi
          
          echo "" >> $GITHUB_OUTPUT
          echo "${delimiter}" >> $GITHUB_OUTPUT

      - uses: anthropics/claude-code-action@v1
        if: steps.determine-trigger.outputs.should-run == 'true'
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          use_sticky_comment: true
          prompt: |
            REPO: ${{ github.repository }}
            PR NUMBER: ${{ github.event.pull_request.number }}
            FRAMEWORK: ${{ inputs.framework }}

            PR CONTEXT COMPLETION:
            - Fetch PR metadata with `gh pr view ${{ github.event.pull_request.number }} --json title,body,closingIssuesReferences,number,files`.
            - For each linked issue, fetch `title` and `body` with `gh issue view <issue> --json title,body,labels,number`.
            - If the PR description is empty, placeholder text, or missing a what/why summary, build a concise markdown body that includes: summary, linked issues, requirements or acceptance criteria from the issue, risks/affected areas, and testing status (say "Testing: not provided" if unknown).
            - If the PR already has meaningful content, append an "Issue context" section with any missing details instead of overwriting user text.
            - Update the PR body with `gh pr edit ${{ github.event.pull_request.number }} --body "<markdown>"` only when you have new context to add.
            - Whenever you modify the PR body, add a new section called "Additional context (Claude)" with whatever you're adding.
            - If no issue is linked, gather candidates with:
              - `gh issue list --state open --limit 20 --json number,title,body,labels`
              - `gh issue list --state open --search "<PR title> in:title,body" --json number,title,body,labels`
            - Rank candidates against PR title/body and touched file paths. If exactly one issue is an obvious match, append `Closes #<number>` to the PR body so it links, or if it doesn't fully close the issue, append `Refers to #<number>`. Do not add anything if confidence is low or if a closing keyword already exists.
            - If we're confident and we add an issue, add some context about it to the PR body.

            Review this pull request and ONLY comment on:
            - Actual bugs, errors, or broken functionality
            - Security vulnerabilities
            - Critical performance issues that will cause problems
            - Type errors or runtime errors

            CRITICAL RULES:
            - DO NOT praise or compliment code
            - DO NOT comment on lines that are correct or well-written
            - DO NOT suggest improvements unless they fix a bug or improve the code
            - For each comment, explain WHY it's a bug/error and what will break
            - Keep comments concise and technical - no fluff
            - If there are no bugs, post nothing
            - Ignore generated files, lock files, and build artifacts

            Codebase context:
            - Follow CLAUDE.md (if available), and the project rules.
            - You can find the project rules as markdown files in the .cursor/rules directory.
            - Treat CLAUDE.md and the rules like gospel.

            CURSOR RULES CONTENT:
            ${{ steps.cursor-rules.outputs.content }}

            FRAMEWORK-SPECIFIC RULES (${{ inputs.framework }}):
            ${{ steps.framework-rules.outputs.content }}

            Note: The PR branch is already checked out in the current working directory.

            Use `gh pr comment` for top-level feedback.
            Use `mcp__github_inline_comment__create_inline_comment` to highlight specific code issues.
            If you already left an inline comment, don't leave another one. You may link to the existing comment from
            the new summary if it's still relevant.
            Only post GitHub comments - don't submit review text as messages.

          claude_args: |
            --allowedTools "mcp__github_inline_comment__create_inline_comment,Bash(gh pr comment:*),Bash(gh pr diff:*),Bash(gh pr view:*),Bash(gh issue view:*),Bash(gh issue list:*),Bash(gh pr edit:*)"
